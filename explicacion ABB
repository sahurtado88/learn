# WORKFLOW DOCKER Y AZURE APP

Nombre del Workflow: El flujo de trabajo se llama "Build and deploy container app to Azure Web App - uniqueip".

Desencadenadores:

Se ejecuta cuando hay un push a la rama master.
También se puede ejecutar manualmente usando workflow_dispatch.
Jobs (Tareas):

Build (Construcción):

Entorno: Se ejecuta en ubuntu-latest.
Pasos:
Checkout del código: Clona el repositorio en la máquina de ejecución.
Configuración de Docker Buildx: Configura Docker Buildx, una extensión para construir imágenes Docker.
Inicio de sesión en el registro de Docker: Inicia sesión en Docker Hub utilizando credenciales almacenadas en secretos.
Construcción y push de la imagen Docker: Construye la imagen Docker usando el Dockerfile y la sube a Docker Hub con una etiqueta única basada en el hash del commit (github.sha).
Deploy (Despliegue):

Entorno: Se ejecuta en ubuntu-latest.
Dependencia: Necesita que la tarea build se complete primero.
Pasos:
Despliegue en Azure Web App: Utiliza la acción de Azure para desplegar la imagen Docker en una aplicación web de Azure especificada. Usa un perfil de publicación almacenado en secretos y la URL de la imagen Docker construida en el paso anterior.
En resumen, este workflow construye una imagen Docker de tu aplicación, la sube a Docker Hub, y luego despliega esa imagen en una aplicación web de Azure.

# TERRAFORM

Nombre del Workflow: El flujo de trabajo se llama "Terraform".

Desencadenadores:

Se ejecuta manualmente usando workflow_dispatch, lo que permite seleccionar el entorno de despliegue (devel, stage o prod).
Jobs (Tareas):

Terraform:

Entorno: Se ejecuta en ubuntu-latest.
Variables de entorno: Se configuran varias variables de entorno utilizando secretos almacenados en GitHub, como las credenciales de Azure y las credenciales de PostgreSQL.
Directorio de trabajo: Se establece el directorio de trabajo en ${{ github.workspace }}/infraestructure.
Pasos:
Checkout del código: Clona el repositorio en la máquina de ejecución.
Configuración de Terraform: Configura la versión de Terraform (1.7.5).
Inicialización de Terraform: Ejecuta terraform init para inicializar el entorno de Terraform.
Seleccionar o crear espacio de trabajo: Selecciona el espacio de trabajo correspondiente al entorno seleccionado (devel, stage o prod). Si no existe, lo crea.
Plan de Terraform: Ejecuta terraform plan para generar un plan de ejecución usando el archivo de variables correspondiente al entorno seleccionado.
Aplicar Terraform: Ejecuta terraform apply para aplicar los cambios del plan de ejecución, aprobando automáticamente los cambios.

En resumen, este workflow permite desplegar infraestructura usando Terraform en diferentes entornos (devel, stage, prod). Inicializa Terraform, selecciona o crea el espacio de trabajo adecuado, genera un plan de ejecución y aplica los cambios necesarios.

# PYTHON

Importaciones y configuración de Flask:

Importa las bibliotecas necesarias: Flask, request, jsonify, SQLAlchemy y os.
Crea una instancia de la aplicación Flask.
Configura la URI de la base de datos PostgreSQL, obteniéndola de una variable de entorno o usando una URI por defecto.
Configuración de SQLAlchemy:

Desactiva el seguimiento de modificaciones de SQLAlchemy para ahorrar recursos.
Crea una instancia de SQLAlchemy asociada a la aplicación Flask.
Definición del modelo Visitor:

Crea una clase Visitor que representa la tabla de visitantes en la base de datos. Tiene dos columnas: id (clave primaria) e ip (única y no nula).
Ruta principal ('/'):

Obtiene la IP del visitante usando request.remote_addr.
Verifica si la IP ya está en la base de datos.
Si no está, crea un nuevo registro de visitante y lo guarda en la base de datos.
Consulta todos los visitantes en la base de datos y devuelve el número de visitantes únicos.
Ruta de versión ('/version'):

Devuelve la versión de la aplicación en formato JSON.
Ejecución de la aplicación:

Si el script se ejecuta directamente (__name__ == '__main__'), crea todas las tablas en la base de datos y ejecuta la aplicación Flask en el puerto 5000.
En resumen, este código crea una aplicación web simple que cuenta el número de visitantes únicos basándose en sus direcciones IP y muestra el total cuando se accede a la ruta principal. También proporciona una ruta para obtener la versión de la aplicación.

Imagen Base:

dockerfile
Copy code
FROM python:3.8-slim
Usa la imagen oficial de Python 3.8 basada en Debian Slim como imagen base. Es una imagen ligera que contiene lo esencial para ejecutar Python.
Directorio de Trabajo:

dockerfile
Copy code
WORKDIR /app
Establece el directorio de trabajo en /app. Todos los comandos posteriores se ejecutarán en este directorio.
Copiar Archivos:

dockerfile
Copy code
COPY app /app
COPY app/requirements.txt /app
Copia el contenido del directorio app en el directorio de trabajo /app.
Copia el archivo requirements.txt en el directorio de trabajo /app.
Instalar Dependencias:

dockerfile
Copy code
RUN pip install --no-cache-dir -r requirements.txt
Instala las dependencias de Python listadas en requirements.txt usando pip. La opción --no-cache-dir evita que pip guarde archivos en caché para reducir el tamaño de la imagen.
Exponer Puerto:

dockerfile
Copy code
EXPOSE 5000
Expone el puerto 5000, que es el puerto por defecto en el que Flask ejecuta la aplicación. Esto permite que la aplicación sea accesible a través de este puerto.
Comando por Defecto:

dockerfile
Copy code
CMD ["python", "app.py"]
Especifica el comando que se ejecutará cuando se inicie un contenedor a partir de esta imagen. En este caso, ejecuta el archivo app.py usando Python.
En resumen, este Dockerfile define cómo construir una imagen Docker para una aplicación Python basada en Flask. Copia el código de la aplicación y las dependencias, instala las dependencias necesarias, expone el puerto 5000 y especifica el comando para iniciar la aplicación.

# En el contexto de tu Dockerfile, usar CMD es apropiado porque:

Permite mayor flexibilidad al usuario para cambiar el comando de ejecución sin modificar el Dockerfile.
Es sencillo y directo, adecuado para el propósito de ejecutar la aplicación Flask por defecto.
Si necesitas que el contenedor siempre ejecute un comando específico y no deseas que se anule fácilmente, podrías considerar ENTRYPOINT. Sin embargo, para la mayoría de las aplicaciones simples, CMD proporciona la flexibilidad y facilidad de uso necesarias.

# 

Versión
yaml
Copy code
version: '3.3'
Especifica la versión de Docker Compose. Aquí se está utilizando la versión 3.3.
Servicios
Servicio db
yaml
Copy code
db:
  image: postgres:11
  environment:
    POSTGRES_DB: visitors
    POSTGRES_USER: user
    POSTGRES_PASSWORD: password
  volumes:
    - db_data:/var/lib/postgresql/data
image: Usa la imagen de PostgreSQL versión 11.
environment: Define las variables de entorno necesarias para configurar PostgreSQL:
POSTGRES_DB: Nombre de la base de datos.
POSTGRES_USER: Usuario de la base de datos.
POSTGRES_PASSWORD: Contraseña del usuario de la base de datos.
volumes: Monta un volumen llamado db_data en el directorio /var/lib/postgresql/data dentro del contenedor para persistir los datos de la base de datos.
Servicio web
yaml
Copy code
web:
  build: .
  ports:
    - "5000:5000"
  environment:
    DATABASE_URL: postgres://user:password@db:5432/visitors
  depends_on:
    - db
build: Construye la imagen de Docker usando el Dockerfile en el directorio actual (.).
ports: Mapea el puerto 5000 del contenedor al puerto 5000 del host, permitiendo acceder a la aplicación Flask desde el host.
environment: Define la variable de entorno DATABASE_URL que contiene la cadena de conexión a la base de datos PostgreSQL. Aquí, db es el nombre del servicio de la base de datos que Docker Compose resolverá automáticamente a la dirección IP del contenedor de la base de datos.
depends_on: Especifica que el servicio web depende del servicio db, asegurando que el contenedor de la base de datos se inicie antes que el contenedor de la aplicación web.
Volúmenes
yaml
Copy code
volumes:
  db_data:
Define un volumen llamado db_data que se utilizará para persistir los datos de la base de datos PostgreSQL.
Resumen
Este archivo docker-compose.yml define una configuración para ejecutar dos servicios en contenedores:

db: Un contenedor PostgreSQL configurado con una base de datos llamada visitors y credenciales especificadas.
web: Un contenedor que ejecuta la aplicación web Flask, construido desde el Dockerfile en el directorio actual. La aplicación Flask se conecta a la base de datos PostgreSQL utilizando la cadena de conexión proporcionada en la variable de entorno DATABASE_URL.
Los datos de la base de datos se persisten en un volumen llamado db_data, y la aplicación web es accesible a través del puerto 5000 del host.
